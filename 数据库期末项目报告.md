# 数据库期末项目报告

计64 范轩玮

计64 刘佳阳

## Usage

如果是从Github下载源码，请先使用下列方法初始化子模块。

```bash
git clone https://github.com/jiayang-16/DBProject113b.git
git checkout dev
git submodule init
git submodule update
cd DBProject113b
```

接着使用Cmake运行项目。

```bash
mkdir build
cd build
cmake ..
make
./main
```

## 系统架构示意图

![系统架构](/Users/alexfan/Desktop/系统架构.jpg)

## 参考的开源库

### SQL命令解析

[SQL-Parser](https://github.com/AlexFxw/sql-parser)

我们fork了此[开源库](https://github.com/hyrise/sql-parser)进行命令的解析，由于其未提供对外键的支持以及我们的insert同标准MySQL语句有点出入，因此我们针对这两点对yacc进行了修改，修改记录可见我们fork的repo的commit记录。

### B+树

[zcbenz/BPlusTree](https://github.com/zcbenz/BPlusTree)

在索引模块中，我们使用此开源库的b+树实现，由于其原先并未支持重复键值的插入，我们针对这点对源码稍加修改，故IndexModule里的代码和开源库的源码有些微出入。

## 各模块设计

### 记录管理模块

| 类名          | 功能                                                         |
| ------------- | ------------------------------------------------------------ |
| RM_Manager    | 调用FileManager中的接口实现文件的新建、打开、关闭、删除      |
| RID           | 实现记录的唯一标记，储存页号+记录编号                        |
| PageHead      | 实现文件信息（储存在文件第一页）的定义，包括记录长度、每页最大记录数、存在记录总数、存在页数、每页的空闲情况 |
| RM_FileHandle | 在RM_Manager中使用，实现记录的获取、插入、删除、更新         |
| RM_FileScan   | 在文件中查找满足条件的记录                                   |
| RM_Record     | 储存记录（RID+记录内容)                                      |

说明：记录管理模块主要提供对文件的直接访问接口，读取文件后储存为将文件中的记录储存为record的形式，在RM_FileHandle中存储文件的信息。

### 索引模块

索引模块主要包括B+树的实现和管理索引的类IndexHandle。B+树的核心功能使用开源库实现，并且在其基础上实现了对索引的操作。

对每个table单独建立索引，索引存储为命名为“tableName_Index”的文件夹，在其中对每列建立索引文件。每列的索引文件是一个B+树，键为某个记录的相应列内容，值该记录的RID。对于一个表文件的所有索引，我们使用IndexHandle类。至于整个数据库的若干表间的IndexHandle是由IndexManager管理的。

### 系统管理模块

系统管理模块主要实现了基本的数据定义语言。每个数据库存储为文件夹，其中的每个表存为单独的文件。其中create table语句支持外键。

### 查询解析模块

查询解析模块主要实现了基本的数据操作语言。查询语句的解析使用开源库实现，并且在其基础上实现了对外键的解析。将语句解析之后，根据语句类型调用其他模块提供的接口进行实际的操作。

### 拓展功能

1.外键的实现：将表的外键信息存在文件首页，在更新记录时会查询其外键信息。

2.update语句支持四则运算：在解析update语句时，若set子句的表达式包括四则运算，会先算出结果，再更新左值代表的列。支持字符串的拼接。支持与列的四则运算，形如x=y+1。

3.使用Index加快查询速度。

## 主要接口说明

以下将列出我们项目里主要使用的接口，将不涉及private和非核心功能的辅助方法。

### Record Module

#### RM_Manager

```c++
RM_Manager(char *dbName)
```

唯一的构造函数，创建一个负责管理路径为dbName表的RM_Manager类。

- *dbName: 表文件的路径
- 返回0代表成功，1代表失败

```c++
int createFile(const char* name, int recordSize, int cNum)
```

创建表文件的方法。

- *name: 表文件的路径
- recordSize: 该表文件一条记录的长度，以sizeof(uint)（4Byte）为单位。
- 返回0代表成功，1代表失败

```c++
bool openFile(const char* name, RM_FileHandle &fileHandle)
```

开启表文件。

- *name: 表文件的路径
- fileHandle: 用来处理该表文件的fileHandle对象，由于一个表文件对应一个fileHandle，所以这个参数是必要的。
- 返回值：是否成功开启表文件。

```c++
int closeFile(RM_FileHandle &fileHandle)
```

关闭fileHandle所关联的表文件，主要是调用fileHandle.updateHead()方法更新表文件记录。

- fileHandle: 将被关闭的表文件所关联的fileHandle对象。

```c++
int deleteFile(const char* name)
```

移除表文件和相应的索引目录。

- name: 表文件路径
- 返回值为0表示操作成功，1为失败

```c++
void showFile(const char* name)
```

打印表文件的相关信息。

- name: 表文件路径

```c++
void showAllFile()
```

打印该数据库下所有表文件的信息。

#### RM_FileHandle

```c++
RM_FileHandle(bool _init = true)
```

创建一个新的FileHandle，_init为真时代表这个fileHandle是用来处理新创建的表文件的。

```c++
int updateHead()
```

将FileHandle里记录的相关信息写回文件，例如现在的位图、主键、外键、记录总数和页数等等。

```c++
int init(int _fileId, BufPageManager* _bufpm, string tableName)
```

从文件里初始化fileHandle的相关信息，还原位图、外键、主键及其他信息的方法，在RM_Manager的openFile方法里调用。

- _fileId：文件描述字，所以此方法应该在成功开启表文件时调用。
- _bufpm: openFile里建立的BufPageManger对象指针。
- tableName：表文件名
- 返回值0代表成功。

```c++
int GetRec(const RID &rid, RM_Record &rec)
```

获取fileHandle关联的表文件里rid对应的记录。

- rid: 想要获取的记录的RID信息。
- rec: 将获取到的记录赋值给rec。
- 返回值0代表成功，否则获取失败。

```c++
int InsertRec(RM_Record& pData)
```

向表文件插入记录，实际上是使用BufPageManager先放到缓冲里，成功则位图和记录数量会相应地修改。插入时会检查主键、记录类型、记录长度、外键等约束条件是否满足，若否则插入失败。

- pData: 想要插入文件的记录。
- 返回值0代表成功，否则获取失败。

```c++
int DeleteRec(const RID &rid)
```

删除rid对应的记录，同时删除rid对应记录中各栏位的索引，不满足外键约束从而会破坏一致性的删除操作将失败。

```c++
int UpdateRec(RM_Record &rec)
```

更新rec，会先获取rec的RID信息，若rid无效更新失败，若有效则：

1. 检查delete原先rid 原先关联的record的操作是否合法
2. insert新record的操作是否合法

若两个条件皆满足则更新操作成功，否则失败。

- rec: 想要更新的记录。
- 返回值0代表成功。

```c++
int GetAttrIndex(const string &attrName, int &index)
```

给出attrName对应的列号并赋给index，若attrName并非fileHandle对应表文件的列名，操作失败返回非零值。

```c++
void SetTitle(vector<string> t)
```

设置fileHandle的列名信息，在创建新表文件时会用到。

```c++
int AddForeignKey(RM_Manager *rmg, string chartName, string attrName, int col)
```

增加外键信息，将本文件中第attrName的外键设置为某个表文件的某一列，若该表不存在或该列不为主键，则操作失败。

- rmg：RM_Manager对象指针，用来访问其他表文件。
- chartName：相关联的表文件的名字。
- attrName：本表文件里要关联的列名。
- col：相关联的表文件的列号。
- 若成功返回0。

```c++
bool isMainKey(uint key)
```

若key值是主键则返回true，否则返回false。

```c++
int GetForeignKeyInfo(int pos, pair<string, int> &info)
```

用来获取外键信息，外键信息由<chartName, col> 的对来表示，代表pos位的外键为chartName表文件的第col列，若pos为非外键或是pos非法则函数返回1。

- pos：fileHandle当前关联文件欲了解信息的列号
- info：外键信息的表名-列号对

```c++
int InitIndex(bool forceEmpty = false)
```

初始化索引列。

- forceEmpty：为真时重新建立索引，否则读取之前建立的索引文件。

```c++
void PrintTitle();
void PrintTitle(vector<int> colName);
```

根据参数（参数为空默认为全部）打印相应列的标题。

```c++
int SetMainKey(std::vector<int> mainKeys);
```

设置主键信息。

- mainKeys：存放的内容代表相应列为主键。

```C++
int GetAllRecord(vector<RM_Record> &result)
int GetAllRid(list<RID> *result)
```

往参数的引用里赋值当前文件里全部的记录/有效的RID。

#### RM_FileScan

这个类负责的主要任务是从文件中获取符合条件的记录，每次OpenScan代表增加一个条件（多重条件取交集），其他模块可以透过OpenScan和GetNextRec对文件进行查询，用来支持对whereclause的处理。

```c++
int OpenScan(RM_FileHandle &fileHandle, int col, IM::CompOp comOp, char *value)
```

基于范围的查询，用来支持形如a.name = 'hot pot'或是b.id < 10之类的操作。

- fileHandle：与欲查询文件相关联的fileHandle。
- col：欲查询的列。
- comOp：比较符号，于命名空间IM内枚举的常见关系符号。
- value：界值的字符串，以name为例，这一栏可以是"mike"之类的。
- 操作成功返回0。

```c++
int OpenScan(RM_FileHandle &fileHandle, int col, bool isNull)
```

基于空与非空的查询，用来支持`where id is null`这样的查询。

- fileHandle：与欲查询文件相关联的fileHandle。
- col：欲查询的列。
- isNull：true代表搜索该列为空的记录，false代表搜索该列不为空的记录。
- 操作成功返回0。

```c++
int ResultNum(){return scanResult->size();}
```

返回值代表扫描结果的数量。

```c++
int GetNextRec(RM_FileHandle &fileHandle, RM_Record &rec)
```

将下一笔符合条件的记录赋值给rec，相当于是把RM_FileScan对象维护的curResult (一个关于扫描结果的迭代器)的值++。若已经遍历完搜索结果了，则函数值返回1，否则返回0。

```c++
int CloseScan()
```

结束一次扫描时调用，会清空当前扫描结果。

#### RM_Record

用来表示一笔记录的类，每条记录里包含

1. null位图：表示该记录某列是否为空。
2. mData：BufType类型，记录的内容。
3. bufSize：整个记录的长度
4. recordSize：记录不含null位图的长度。
5. mRid：记录对应的RID。

```c++
int SetRecord(BufType pData, int size, int cNum)
```

设定一条记录的值。

- pData：将要赋给记录的内容。
- size：记录对应的长度（以uint的长度为单位）
- cNum：记录的列数。

```c++
BufType GetData () const; // 返回不包括NULL位图的内容
BufType GetBuf () const;// 返回整个mData，包括NULL位图
```

用来返回记录内容的方法，区别如注释。

```c++
int GetRid(RID &rid) const;
int SetRID(RID &rid);
```

用来获取/设定某条记录的rid值的方法。

```c++
int RecordSize() const { return recordSize;	}
int BufSize() const { return bufSize; }
```

用来获取记录内容，分别代表带和不带null位图。

```c++
bool IsNull(int pos);
void SetNull(int pos);
```

查询/设定某条记录第pos位的null属性的方法。

#### RM_node

RM_Record的一个辅助结构，用来表示一条记录中某一列的内容。

```c++
RM_node(int content);
RM_node(float content);
RM_node(string content);
```

基于不同参数的构造方法，当新增一个列时可以直接new一个出来RM_node出来。

```c++
bool CmpCtx(IM::CompOp compOp, string value);
```

判断RM_node的内容和value相比符不符合compOp定义的关系。

- compOp: 比较关系。
- value：待比较的值。
- 若符合返回true，否则返回false。

```c++
BufType getCtx()
```

获取RM_node的内容。

#### DualScan

用来处理表连接运算，可以比较两个表之间的关系。

```c++
int OpenScan(list<ScanQuery> queryList);
```

根据询问列表的内容进行搜索，多个条件间取交集。

```c++
int CloseScan()
```

结束查询。

```c++
int GetNextPair(pair<RID, list<RID>> &item);
```

返回下一条查询结果，<RID, list<RID>> 的第一项代表第一个表的RID，后面的list代表与之关联符合条件的第二个表的记录的RID。若已经没有下一条了则返回1，否则函数值返回0。

#### ScanQuery

用来定义对于双表的查询，有两种形式：

```c++
ScanQuery(RM::ScanTarget scanTarget, int col, IM::CompOp cmpOp, char *value)
ScanQuery(RM::ScanTarget scanTarget, int col, bool isNull)
```

对于两张表中某一张表进行扫描，相当于是对其中一张表应用单表条件，方法类似于RM_FileScan中所述。

- scanTarget：条件是和第一张表还是第二张表有关，是一个枚举量。
- 其余参数可见RM_FileScan的OpenScan方法。

```c++
ScanQuery(int mCol, IM::CompOp cp, int vCol);
```

查询两个表之间的关联。

- mCol：第一张表欲比较的列号。
- vCol：第二张表欲比较的列号。
- cp：比较关系。

结合ScanQuery和DualScan，可以完成表连接查询，依序将WhereClause中的条件以ScanQuery的形式放到list中传给DualScan即可。

#### RecordHandler

用来处理关于Record的操作，和RM_FileHandle相关联，此类中记录和Record相关的信息，例如列数量、列类型等。

```c++
int PrintRecord(RM_Record &record);
```

打印记录。

```c++
int PrintRecord(RM_Record &record, vector<int> colIndex);
```

打印记录中的某些列的内容。

- record：待打印的记录
- colIndex：需要打印的列号

```c++
int SetColumn(int pos, RM_Record &record, RM_node &input);
```

设置某列的内容，待设置的内容以RM_node的形式表示，在update时会用到。

- pos：待设定的列号
- record：待设定的记录
- input：要替换该列的内容
- 操作成功返回0

```c++
RM::ItemType* GetItemType();
```

返回这个表里记录规范的数据类型，以指针表示的数组。

```c++
int* GetItemLength();
```

返回这个表里的记录每列的数据长度，以指针表示的类型。

```c++
int SetItemAttribute(int pos, int length, RM::ItemType itemType, bool isNull);
```

用来设定某一列的规范，对应与建表时对每个列类型、长度等信息的规定。

```c++
int IsAllowNull(int pos);
```

查询某个记录第pos为是否允许为空，是返回1，否返回0。

```c++
int MakeRecord(RM_Record &record, vector<RM_node> &items);
```

接收items定义的列内容，基于RecordHandler维护的记录信息新建一条记录并赋值给参数引用record，若items的内容在相应列不符合维护的类型/长度/null信息，则创立记录失败，类型检查基于这个函数实现。

### IndexModule

#### IndexManager

这个类用来管理全局的索引处理，提供了静态方法用以获取不同表名对应的索引，由于在切换文件时需要更新索引文件，频繁地开启/关闭文件会导致对索引文件的大量I/O，因此维护这个类来避免这个情形。

```c++
static int GetIndexHandler(string tableName, IM::IndexHandle *handler);
static int SetIndexHandler(string tableName, IM::IndexHandle *handler);
```

获取/设定tableName对应的IndexHandle，Get时若不存在，函数值返回1，其余情况返回0。

#### IndexHandle

这个类用来处理关于索引的操作，一个表文件对应一个IndexHandle，负责维护有设置索引的列的b+树。

```c++
IndexHandle(int cNum);
```

构造函数。

- cNum：关联的文件的列数。

```c++
int SetIndexHandle(vector<string> tt, string idxPath);
```

设置索引内容。

- tt：关联的表文件的标题内容，用作索引文件名称，例如id, name之类的。
- idxPath：用来存放索引文件的目录，通常作为该数据库的一个子目录。

```c++
int CreateIndex(char *indexName, int pos, bool forceEmpty);
```

创建索引。

- indexName：待创建的索引名称
- pos：对应的列号
- forceEmpty：建立一个空的索引文件或是尝试从已有索引文件载入（用以重建B+树）

```c++
int DeleteIndex(char *indexName, int pos);
```

删除索引。

```c++
int IndexAction(IndexAction actionType, RM_Record &record, RM::RecordHandler *recordHandler);
```

对索引进行操作，首先根据recordHandler得到record中各列的内容，然后在IndexHandle维护的B+树表中做相应的操作。

- actionType: 有INSERT, DELETE, UPDATE三种情况，分别在对表做对应操作时对所应调用。

```c++
int SetIndex(int pos, bool value = true);
```

决定某列是否建立索引。

```c++
int SearchRange(list<RID> &result, char* left, char* right, CompOp comOP, int col);
```

基于索引搜索，并将结果存在result中。

```c++
bool IsIndex(int pos);
```

返回某个位置是否是索引。

```c++
bool Existed(int pos, char *key);
```

在索引里查询pos位的B+树里是否存在键值为key的项。

## CommandModule

### 系统命令模块接口说明

```c++
int CreateDB(char *dbName);
```

创建数据库文件夹。

```c++
int DropDB(char *dbName);
```

（递归）删除数据库文件夹。

```c++
DIR* UseDB(char *dbName);
```

切换当前数据库，返回opendir操作的返回值。

```c++
int showDB(char *dbName);
int showAllDB();
```

打印数据库文件夹下各个表文件的名字与信息。

### Parser 

> 数据库操作命令解析模块接口说明。

```c++
int ParseDBCommand(string commond);
```

解析传入的SQL语句指令，并对数据库作出相应的操作。

- command：SQL语句。

```c++
void ParseInput(string filePath)
```

对于给定路径的数据库（包括多张表）提供基于标准输入输出的交互环境。

#### 说明

Parser模块中包括了其他许多的内部函数，主要是将对开源工具sql-parser的整合以及与其他三个模块的调用，但最终曝露给外部调用者的接口仅有以上两个函数。

## 实验结果
在验收的黑箱测试里，通过了测试点1～8，第九个（大数据量的表连接）发生了运行期错误，具体各个功能的完成情况如下所列。
1. 支持插入记录时的错误类型检查。
2. 支持插入记录时的错误长度检查。
3. 支持删除记录
4. 支持更新记录
5. 支持插入/更新记录的主键约束检查
6. 支持多条件的查询
7. 支持基础的更新以及四则运算的记录更新，如下（假定对id的操作不会造成主键重复）
```sql
update customer set name=‘PersonA’ where id < 500
update customer set id=id+100000
```
8. 表连接的查询，通过检查点8，但是在数据量比较大的检查点9（数据量大概100000 * 80000）发生了未能排查的运行期错误。
9. 外键性质的部分支持，在数据量较小时（small dataset的数据量）建立外键是可行的。但是在数据量变大（验收时food orders的全部测试集）之后在插入时遇到运行期了错误，导致验收时移除了80000～100000数据量的food、orders的外键。
10. 在外键成功插入的前提下，可以在更新和删除时满足外键约束。
## 小组分工
大致分工如下所示，实际上部分工作具有一定的重合性，可参考Github Repo的commit和issue分配情况。
### 范轩玮
1. 项目的cmake工具的编写与维护，包括开源工具整合里的编译问题等。
2. 索引模块的实现，包括对开源B+树的修改与整合。
3. 表连接：RecordModule 里的 FileScan类、DualScan类
4. RecordModule里的RecordHandler类
5. 外键功能的后台实现（最后仅带部分bug地实现）
6. 命令解析模块里对于Insert方法的支持
7. 后期对于RecordModule里的方法增加了一些补充，包括文件头和记录格式的一些位操作方法。
8. 主要的调试工作，包括部分文件的单元测试（基于Google Test）
9. 接口文档、实验结果的编写
### 刘佳阳
1. 记录模块中RM_FileHandle, RM_Manager的实现。
2. 页式文件系统和BufPageManager与本项目的对接
3. 系统命令模块
4. 命令解析模块中对于开源工具sql-parser未包含的一些新特性的支持，例如外键功能的解析。
5. 命令解析模块与其他模块的对接（Parser.hpp文件）
6. 四则运算查询的支持，即形如update tablename set id = id+1的语句
7. 系统架构文档的编写
8. 模块设计文档的编写
9. 部分的调试工作